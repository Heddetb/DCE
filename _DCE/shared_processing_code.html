<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Processing Code Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script>hljs.highlightAll();</script>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            padding: 20px;
        }
        pre {
            text-align: left;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #f4f4f4;
            display: inline-block;
            max-width: 80%;
            overflow-x: auto;
            white-space: pre-wrap; /* Ensures code breaks properly */
        }
        button {
            margin-top: 10px;
            padding: 8px 15px;
            border: none;
            background: #007bff;
            color: white;
            cursor: pointer;
            border-radius: 5px;
        }
        button:hover {
            background: #0056b3;
        }
    </style>
</head>
<body>
    <h2>Processing Code Viewer</h2>
    <pre><code id="processingCode" class="language-java"></code></pre>
    <br>
    <button onclick="copyCode()">Copy Code</button>

    <script>
        const rawCode = `import nl.tue.id.oocsi.*;
import ddf.minim.*;
import java.util.ArrayList;
import processing.core.PVector;

OOCSI oocsi;
Minim minim;
AudioPlayer chopSound, pickaxeSound, rockSound;

// Scene Management
int scene = 1; // 1 = Trees, 2 = Wall, 3 = Flower

// Tree Variables
int numTrees = 6;
float[] treeAngles = new float[numTrees];
boolean allTreesFallen = false;
int chopCount = 0;

// Wall Variables
boolean wallCollapsed = false;
ArrayList<PVector> fallingRocks = new ArrayList<>();
int rocksFallen = 0;
int wallHits = 0;
int requiredWallHits = 5; // Increase difficulty
boolean collapseStarted = false;

// Flower Variables
int waterCount = 0;
boolean flowerGrown = false;
String message = "";
float flowerHeight = 0;
boolean growing = false;
ArrayList<PVector> raindrops = new ArrayList<>();
int requiredWaterings = 4;

// Gyro Variables
float gyroThreshold = 2.0; // Detect movement
float previousGyroValue = 0;

void setup() {
  size(800, 600);
  minim = new Minim(this);
  chopSound = minim.loadFile("chop.mp3");
  pickaxeSound = minim.loadFile("pickaxe.mp3");
  rockSound = minim.loadFile("rock.mp3");
  background(200, 200, 255);
  drawGround();
  
  // Initialize OOCSI
  oocsi = new OOCSI(this, "Environment", "oocsi.id.tue.nl");
  oocsi.subscribe("DCE2025/team-11", "handler");
}

void draw() {
  background(200, 200, 255); // Redraw the background to clear previous frames
  drawGround();
  drawRaindrops();
  
  if (scene == 1) {
    drawTrees();
  } else if (scene == 2) {
    drawWall();
  } else if (scene == 3) {
    drawFlowerScene();
  }
}

void drawTrees() {
  for (int i = 0; i < numTrees; i++) {
    pushMatrix();
    translate(width / (numTrees + 1) * (i + 1), height - 100);
    rotate(treeAngles[i]);
    drawTree(0, 0);
    popMatrix();
    
    if (allTreesFallen && treeAngles[i] > -HALF_PI) {
      treeAngles[i] -= 0.02;
    }
  }
  
  if (allTreesFallen && treeAngles[numTrees - 1] <= -HALF_PI) {
    delay(1000);
    scene = 2;
    resetGyroState();
  }
}

void drawTree(float x, float y) {
  stroke(100, 50, 0);
  strokeWeight(10);
  line(x, y, x, y - 150);
  fill(34, 139, 34);
  ellipse(x, y - 170, 100, 100);
}

void drawWall() {
  background(120, 120, 120);
  drawFallingRocks();
  
  if (wallCollapsed && !collapseStarted) {
    collapseStarted = true;
    rockSound.rewind();
    rockSound.play();
    
    // Spawn extra rocks when collapse starts
    for (int i = 0; i < 100; i++) {
      fallingRocks.add(new PVector(random(width), random(height / 2)));
    }
  }
  
  if (collapseStarted && fallingRocks.size() > 0) {
    for (PVector rock : fallingRocks) {
      rock.y += random(2, 5);
    }
  }
  
  if (collapseStarted && !rockSound.isPlaying()) {
    delay(1000);
    scene = 3;
    resetGyroState();
  }
}

void drawFallingRocks() {
  fill(60);
  for (PVector rock : fallingRocks) {
    ellipse(rock.x, rock.y, 50, 50);
    rock.y += 2;
  }
}

void drawFlowerScene() {
  if (growing) {
    growFlower();
  }
  
  drawRaindrops();
  
  if (flowerGrown || growing) {
    drawFlower();
  }
  
  if (flowerGrown) {
    fill(0);
    textSize(100);
    text(message, 100, 100);
  }
}

void drawFlower() {
  fill(34, 139, 34);
  rect(width / 2 - 10, height - 100 - flowerHeight, 20, flowerHeight);

  fill(255, 182, 193);
  noStroke();
  ellipse(width / 2, height - 100 - flowerHeight - 40, 60, 60);
  ellipse(width / 2 - 30, height - 100 - flowerHeight - 20, 60, 60);
  ellipse(width / 2 + 30, height - 100 - flowerHeight - 20, 60, 60);
  ellipse(width / 2 - 20, height - 100 - flowerHeight + 30, 60, 60);
  ellipse(width / 2 + 20, height - 100 - flowerHeight + 30, 60, 60);
  fill(255, 255, 0);
  ellipse(width / 2, height - 100 - flowerHeight, 40, 40);
}

void growFlower() {
  if (flowerHeight < 150) {
    flowerHeight += 1;
  } else {
    growing = false;
    flowerGrown = true;
    message = "clueee";
  }
}

void drawRaindrops() {
  fill(0, 0, 255);
  for (PVector drop : raindrops) {
    ellipse(drop.x, drop.y, 20, 20);
  }
}

void drawGround() {
  fill(139, 69, 19);
  rect(0, height - 100, width, 100);
}

void handler(OOCSIEvent event) {
  if (event.has("phone_value")) {
    float gyroValue = event.getFloat("phone_value", 0);
    println("Gyro value received: " + gyroValue);
    
    if (gyroValue > gyroThreshold && previousGyroValue < gyroThreshold) {
      if (scene == 1) {
        chopTree();
      } else if (scene == 2) {
        processWallHit();
      } else if (scene == 3) {
        processWaterFlower();
      }
    }
    
    previousGyroValue = gyroValue;
  }
}

void chopTree() {
  chopSound.rewind();
  chopSound.play();
  chopCount++;
  if (chopCount == numTrees) {
    allTreesFallen = true;
  }
}

void processWallHit() {
  if (wallHits < requiredWallHits) {
    pickaxeSound.rewind();
    pickaxeSound.play();
    fallingRocks.add(new PVector(random(width), random(height / 2)));
    wallHits++;
  }
  
  if (wallHits >= requiredWallHits) {
    wallCollapsed = true;
  }
}

void processWaterFlower() {
  if (waterCount < requiredWaterings) {
    waterCount++;
    raindrops.add(new PVector(random(width), random(height - 100, height)));
  }
  
  if (waterCount >= requiredWaterings) {
    growing = true;
  }
}

void resetGyroState() {
  previousGyroValue = 0;
}`;

        // Insert code with correct line breaks
        document.getElementById("processingCode").textContent = rawCode;
        hljs.highlightAll(); // Re-highlight syntax

        function copyCode() {
            const textArea = document.createElement("textarea");
            textArea.value = rawCode; // Copy the raw code with correct formatting
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand("copy");
            document.body.removeChild(textArea);
            alert("Code copied to clipboard!");
        }
    </script>
</body>
</html>
